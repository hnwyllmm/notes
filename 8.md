Dostoevsky: Better Space-Time Trade-Offs for LSM-Tree Based Key-Value Stores via Adaptive Removal of Superfluous Merging



# 背景

主流的LSM Tree存储在update的I/O开销和查询I/O开销、存储空间上做权衡比较。除了lagest level的其它层的merge操作会减少点查、大范围查询和存储空间，但是会严重的提高update的成本，update的成本会分摊到各个层级的merge。

这里引入了一些新的东西，比如Lazy Leveling、Fluid LSM-tree和Dostoevsky。

# 1. 介绍

**Key-Value Stores and LSM-Trees**

LSM-Tree 将插入/更新的数据缓存在内存中，到一定量时flush这个数据到存储中作为一个sorted run。LSM 会将这些run以层级的方式组织起来，比较新的数据会在上层。数据更新是out-of-place方式。点查的时候，会从最小的一层开始直到最大的一层。范围查询必须要遍历所有层，还要剔除旧数据。为了提高查询的效率，通常还会增加两个数据结构。第一个是在每个run上加一个fence pointer，记录每个块的第一个key。第二个是每个run创建一个Bloom filter，可以快速过滤掉一些不存在的key。

**The Problem**

LSM Tree的merge操作的频率，就是update I/O开销、查询I/O开销和存储空间放大之前做权衡。

**The Problem's Source**

这里分析了几种场景的最差情况：update、point lookup、range  lookup和space-amplication.

- Update : Update的I/O 开销是分摊到后面的几次merge操作的。在merge操作中，更大的level，会有指数级增长的工作。
- Point lookups。点查的效率依赖Bloom filter。更小的层级有更低的false positive rate。对于不存在的数据，就需要查询到largest level。考虑最差的情况，那就都需要查询到largest level。
- Long range lookups。因为每个层级的数据是按照指数级增长的，最后一层拥有最多的数据，大部分long range查询的I/O会指向largest level。
- Short range lookups。